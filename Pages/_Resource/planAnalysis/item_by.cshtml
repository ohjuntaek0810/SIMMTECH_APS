@page
@model HS.Web.Pages.item_by
@{
    string CLIENT = Model.Params["CLIENT"].AsString();
    string R = Model.Params["R"].AsString();
    string W = Model.Params["W"].AsString();
    string first_plan_id = Model.Params["first_plan_id"].AsString();
}


<script>

    // 최신버번 PLAN_ID
    let first_plan_id = '@first_plan_id';


        // 헤더컬럼 초기값 정의
        const defaultColumns = [
            { dataField: "DIVISION_ID", label: "GROUP", width: 70, editable: false, align:"center"},
            { dataField: "중분류", label: "중분류", width: 80, editable: false, visible:false },
            { dataField: "소분류", label: "소분류", width: 80, editable: false, visible:false },
            { dataField: "CUSTOMER", label: "Customer", width: 120, editable: false },
            { dataField: "ITEM_CODE", label: "ITEM_CODE", width: 110, editable: false },
            { dataField: "MODEL_NAME", label: "Model Name", width: 250, editable: false },
            { dataField: "TOTAL_DEMAND_QTY_SQM", label: "입고 잔량", width: 75, editable: false },
            { dataField: "TOTAL_WIP", label: "전체 WIP", width: 75, editable: false },
            { dataField: "COMPLETE_QTY_SUM", label: "투입잔량", width: 75, editable: false },
            { dataField: "HOLD_WIP_QTY_SQM", label: "Hold WIP", width: 75, editable: false },
            { dataField: "GUBUN", label: "구분", width: 120, editable: false }
        ];

    $hs.handler = {
        "btn_reset" : {
            click: function() {
                // 값 초기화
                $hs.$("pnlSearch").reset();
            }
        },
        "btnSearch": {
            click: function () {

                let toServer = {};
                toServer["terms"] = $hs.$("pnlSearch").val();

                $hs.fetch({
                    command: "search",
                    param: toServer
                }).then(fromServer => {

                    //  조회한 날짜로 헤더컬럼 재설정
                    const searchColumns = [];
                    const srchStartDate = new Date(toServer["terms"].start_date);
                    const srchEndDate = new Date(toServer["terms"].end_date);

                    defaultColumns.forEach(col => searchColumns.push(col));

                    for (let d = new Date(srchStartDate); d.getTime() <= srchEndDate.getTime(); d.setDate(d.getDate() + 1)) {
                        const dateStr = formatDate(d);
                        const column = {
                            dataField: dateStr,
                            label: dateStr,
                            width: 100,
                            editable: false
                        };
                        searchColumns.push(column);
                    }

                    $hs.$("grid").columns(col => {
                        searchColumns.forEach(column => {
                            col.add({
                                dataField: column.dataField,
                                label: column.label,
                                width: column.width,
                                visible: (column.visible === undefined || column.visible === true || column.visible === "True"),
                                fixed: column.fixed === true || column.fixed === "True" ? true : false,
                                editable: column.editable === true || column.editable === "True" ? true : false,
                                type: column.type ? column.type : null,
                                align: column.align ? column.align : null
                            });
                        });
                    });

                    // 납기 -- 주가되는 데이터
                    // toClient["data"] = this.SearchBasic(terms); 
                    // 완성 가능 항목 (WIP or NEW) -- 주가되는 데이터
                    // toClient["dataCompleteable"] = this.SearchCompleteable(terms);
                    // 입고잔량
                    // toClient["dataRemaingStock"] = this.SearchRemaingStock(terms);
                    // 전체 WIP or 투입잔량
                    // toClient["dataTotalWip"] = this.SearchTotalWip(terms);
                    // Hold WIP
                    // toClient["dataHoldCount"] = this.SearchHoldCount(terms);
                    // 현재공정위치 -- 주가되는데이터
                    // toClient["dataCurrentWip"] = this.SearchCurrentWip(terms);

                    /**
                     * 납기 + 완성가능항목 + 현재공정위치로 데이터를 만들기때문에
                     * 세개중에 한개라도 데이터가 있다고 판단되면 나머지 그리드에 그려지는
                     * 납기 + 완성가능 + WIP + NEW + 누적과부족 + WIP 현재 공정 위치 
                     * 이렇게 6가지 항목을 모두 그려줘야한다.
                     * 
                     * 납기를 기준이 되는 정보로 두고 시작. (납기 조회데이터는 전체날짜에 대해서 조회하고 PIVOT에서만 조회조건 날짜를 건다)
                     * 
                     */

                    // 기본그룹
                    let basic_data = fromServer["data"];

                    console.log(basic_data);

                    // for 문 돌면서 fromServer["data"]에다가 기준정보는 더해줘야함 (3, 4, 5번 쿼리들) --> 첫 줄에 나오는 기준정보를 만들기 위함
                    const merged_data = basic_data.map(item => {
                        const remaining = fromServer.dataRemaingStock.find(d => d.ITEM_CODE === item.ITEM_CODE) || {};
                        // 전제 WIP 가져오기
                        const wip = fromServer.dataTotalWip.find(d => d.ITEM_CODE === item.ITEM_CODE && d.WIP_NEW_GBN === "WIP") || {};
                        // 투입잔량 가져오기
                        const inputRemain = fromServer.dataTotalWip.find(d => d.ITEM_CODE === item.ITEM_CODE && d.WIP_NEW_GBN === "NEW") || {};
                        const hold = fromServer.dataHoldCount.find(d => d.ITEM_CODE === item.ITEM_CODE) || {};

                        return {
                            ...item,
                            TOTAL_DEMAND_QTY_SQM: remaining.TOTAL_DEMAND_QTY_SQM || 0,
                            TOTAL_WIP: wip.COMPLETE_QTY_SUM || 0,
                            COMPLETE_QTY_SUM: inputRemain.COMPLETE_QTY_SUM || 0,
                            HOLD_WIP_QTY_SQM: hold.HOLD_WIP_QTY_SQM || 0
                        };
                    });

                    // ++ 납기만있고 WIP이나 NEW가 없는 데이터들===============================
                    const not_in_comp_list = basic_data.filter(item => {
                        const exists = fromServer.dataCompleteable.some(d => d.ITEM_CODE === item.ITEM_CODE);
                        return !exists;
                    }).map(item => item.ITEM_CODE);
                    // 최종 사용 데이터
                    const no_wip_new_data = [];

                    not_in_comp_list.forEach(code => {
                        ["┣ WIP", "└ 신규"].forEach(gubun => {
                            let temp_data = {
                                ITEM_CODE: code,
                                GUBUN: gubun
                            };
                            no_wip_new_data.push(temp_data);
                        });
                    });
                    // -- 납기만있고 WIP이나 NEW가 없는 데이터들===============================

                    // ++ 납기에 있는데 WIP이나 NEW가 하나만 있는 데이터들===============================
                    const partial_status_data = [];

                    basic_data.forEach(item => {
                        const comp_list = fromServer.dataCompleteable.filter(d => d.ITEM_CODE === item.ITEM_CODE);

                        if (comp_list.length === 0) return; // comp_list에 없는 건 제외

                        const hasNEW = comp_list.some(d => d.WIP_NEW_GBN === "NEW");
                        const hasWIP = comp_list.some(d => d.WIP_NEW_GBN === "WIP");

                        // 둘 중 하나만 있는 경우
                        if ((hasNEW && !hasWIP) || (!hasNEW && hasWIP)) {
                            let temp_data = {
                                ITEM_CODE: item.ITEM_CODE,
                                GUBUN: !hasNEW ? "└ 신규" : "┣ WIP"
                            };
                            partial_status_data.push(temp_data);
                        }
                    });
                    // -- 납기에 있는데 WIP이나 NEW가 하나만 있는 데이터들===============================

                    // ++ 완성 가능 데이터 만들기==============================
                    // 완성 가능 데이터 리스트
                    let completion_possible_data = [];

                    basic_data.map(item => {
                        // 해당 ITEM_CODE에 해당하는 모든 comp_data 가져오기
                        const comp_list = fromServer.dataCompleteable.filter(d => d.ITEM_CODE === item.ITEM_CODE);

                        let temp_data = {
                            ITEM_CODE: item.ITEM_CODE,
                            GUBUN: "완성 가능"
                        };

                        searchColumns.forEach(col => {
                            const dateStr = col.dataField;

                            // 날짜 형식인지 확인
                            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                                // NEW 또는 WIP인 것만 합산
                                const sum = comp_list
                                    .filter(d => d.WIP_NEW_GBN === "NEW" || d.WIP_NEW_GBN === "WIP")
                                    .reduce((acc, cur) => acc + (cur[dateStr] || 0), 0);

                                temp_data[dateStr] = sum;
                            }
                        });

                        completion_possible_data.push(temp_data);
                    });
                    // -- 완성가능데이터 ========================================

                    // ++ 누적 과부족 데이터 만들기==============================
                    // 누적 과부족 데이터 만들기
                    let shortage_accumulated_data = [];

                     basic_data.map(item => {
                        const completeList = completion_possible_data.find(d => d.ITEM_CODE === item.ITEM_CODE) || {};
                        const deliveryList = fromServer.data.find(d => d.ITEM_CODE === item.ITEM_CODE) || {};

                        let temp_data = {
                            ITEM_CODE: item.ITEM_CODE,
                            GUBUN: "누적 과부족"
                        };

                        let prevShortage = 0;

                        searchColumns.forEach(col => {
                            const dateStr = col.dataField;

                            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                                const completeQty = completeList[dateStr] || 0;
                                const deliveryQty = deliveryList[dateStr] || 0;

                                const shortageRaw = prevShortage + completeQty - deliveryQty;
                                const shortage = Math.round(shortageRaw * 100) / 100;
                                temp_data[dateStr] = shortage;

                                prevShortage = shortage; // 숫자 그대로 저장
                            }
                        });

                        shortage_accumulated_data.push(temp_data);
                    });
                    // -- 누적 과부족 데이터 만들기=================================
                    // ++ WIP 현재 공정 위치 없는 데이터 만들기 ====================
                    const current_wip_codes = fromServer.dataCurrentWip.map(d => d.ITEM_CODE);

                    // basic_data 기준으로 현재 공정 위치가 없는 ITEM_CODE 필터링
                    const no_current_wip_data = basic_data
                        .filter(item => !current_wip_codes.includes(item.ITEM_CODE))
                        .map(item => item.ITEM_CODE);

                    // 최종 사용 데이터 생성
                    const no_current_wip_result = [];

                    no_current_wip_data.forEach(code => {
                        let temp_data = {
                            ITEM_CODE: code,
                            GUBUN: "WIP 현재 공정 위치"
                        };
                        no_current_wip_result.push(temp_data);
                    });
                    // -- WIP 현재 공정 위치 없는 데이터 만들기 ====================
                    

                    let data = [
                        ...merged_data
                        , ...no_wip_new_data                    // 납기만있고 WIP, NEW 데이터 둘다 없는 데이터들
                        , ...partial_status_data                // 납기에 포함되지만 둘중에 하나만 있는 데이터
                        , ...fromServer["dataCompleteable"]
                        , ...completion_possible_data
                        , ...shortage_accumulated_data
                        , ...fromServer["dataCurrentWip"]
                        , ...no_current_wip_result              // 현재공정위치가 없는 데이터
                    ];

                    console.log(data);

                    // GUBUN 값으로 순서 정하기
                    const gubunOrder = {
                        "납기": 0,
                        "완성 가능": 1,
                        "┣ WIP": 2,
                        "└ 신규": 3,
                        "누적 과부족": 4,
                        "WIP 현재 공정 위치": 5
                    };

                    data.sort((a, b) => {
                        // ITEM_CODE 기준 정렬
                        if (a.ITEM_CODE < b.ITEM_CODE) return -1;
                        if (a.ITEM_CODE > b.ITEM_CODE) return 1;

                        // GUBUN 기준 정렬
                        const orderA = gubunOrder[a.GUBUN] ?? 999;
                        const orderB = gubunOrder[b.GUBUN] ?? 999;
                        return orderA - orderB;
                    });


                    // 그리드에 데이터 입력
                    const processedData = [];
                    let lastItemCode = null;
                    // 그리드에 데이터 넣기전에 ITEM_CODE 중복인거 제거
                    data.forEach(row => {
                        const newRow = { ...row };

                        // ITEM_CODE: 이전 값과 같으면 빈칸
                        if (row.ITEM_CODE === lastItemCode) {
                            newRow.ITEM_CODE = null;
                        } else {
                            lastItemCode = row.ITEM_CODE;
                        }

                        // DIVISION_ID: ITEM_CODE가 있으면 유지, 없으면 빈칸
                        newRow.DIVISION_ID = newRow.ITEM_CODE ? row.DIVISION_ID : "";

                        processedData.push(newRow);
                    });


                    $hs.$("grid").data(processedData);

                    // $hs.$("grid").data(baseItems);

                    const gridInstance = $hs.$("grid")._instance;

                    gridInstance.on("rowPrepared", function (e) {
                        if (e.rowType === "data" && e.data.GUBUN === "WIP 현재 공정 위치") {
                            e.rowElement.css({
                                "border-bottom": "2px solid black"  // 상단 border 강조
                            });
                        }
                    });

                }).catch(e => $hs.errorBox(e))
            }
        },
        "btn_grid_save": {
            click: function () {
                alert('준비중 입니다.');
            },
        },
        "btn_excel_download": {
            click : function() {
                $hs.util.$CommonUtil.excelDownload("grid", "제품별_정보");
            }
        },
        "btn_grid_setting" : {  // dimension 세팅
            click : function() {
                // 그리드 세팅 modal open
                // param : modal_id, grid_id, dimension_grid_id
                $hs.util.$CommonUtil.openGridSettingModal("modalDialog", "grid", "dimension_grid");
            }
        },
        "btnSave_dimension" : { // dimension 변경내용 저장
            click : function() {
                $hs.util.$CommonUtil.saveGridSetting("modalDialog", "grid", "dimension_grid");
            }
        },
        "plan_id" : {
            change : function(data) {
                console.log(data);
                // PLAN ID 선택 시 달력에 시작날짜를 세팅한다.
                // data.value 잘라서 날짜형식으로 바꾸기
                const plan_id_parts = data.value.split("_");
                const date_part = plan_id_parts[1];
                // Date 포맷으로 변경
                const date_format = `${date_part.slice(0,4)}-${date_part.slice(4,6)}-${date_part.slice(6,8)}`;
                const dateObj = new Date(date_format);

                // 이번 달 마지막 날
                const endDate = new Date(dateObj.getTime() + 14 * 24 * 60 * 60 * 1000)

                // 실제 input에 설정
                document.getElementById('start_date').value = formatDate(dateObj);
                document.getElementById('end_date').value = formatDate(endDate);

            }
        },
        "grid": {
            contextHeaderClick: function (data) {
                $hs.util.$CommonUtil.getHeaderContextClick(data);
            },
            headerFormat: function (data) {
                data.cell.css("text-align", "center");
            },
        }
    }

    $hs.load(() => {
        // 현재 localStorage에 저장된 메뉴 ID 가져옴
        var curMenuId = localStorage.getItem("curMenuId"); 
        // 즐겨찾기 여부 체크 후 버튼 리스너 추가
        $hs.util.$CommonUtil.checkFavorite(curMenuId);

        // search
        $hs.ui.button.init({ id: "btnSearch", class: ["smart-btn", "btn-search"] });

        // grid save
        $hs.ui.button.init({ id: "btn_grid_save", enabled: @W });

        // excel download
        $hs.ui.button.init({ id: "btn_excel_download"});
          
        // panel
        $hs.html.panel.init({ id: "pnlSearch" });

        // grid setting
        $hs.ui.button.init({ id: "btn_grid_setting"});
        $hs.ui.button.init({ id: "btnSave_dimension"});

        // grid
        $hs.dx.grid.init({
            id: "grid",
            width: "100%",
            height: "100%",
            sortable: true,
            selectMode: "single",
            rownumber: false,
            filterable: true,
            editable: true,
            handler: true,
            reOrdering: true, // 컬럼 재배치 여부
            headerContextmenu : ["Sort Asc", "Sort Desc", "Sort Clear", "Fixed", "Unfixed", "Hide", "Hide Clear",
                {
                    menu : "CAL",
                    child : [
                        "Count",
                        "Avg",
                        "Max",
                        "Min",
                        "Sum",
                        "Std. Div"
                    ]
                }
            ],
        })

        const _instance = $hs.$("grid")._instance;
        // 컬럼 라인 그리기
        _instance.option('showColumnLines', true);
        _instance.option('rowAlternationEnabled', false);
        _instance.option('showBorders', true);
        _instance.option('scrolling', {
            showScrollbar: 'always',
            useNative: true
        });

        // first_plan_id 잘라서 날짜형식으로 바꾸기
        const plan_id_parts = first_plan_id.split("_");
        const date_part = plan_id_parts[1];
        // Date 포맷으로 변경
        const date_format = `${date_part.slice(0,4)}-${date_part.slice(4,6)}-${date_part.slice(6,8)}`;
        const dateObj = new Date(date_format);

        // dateObj 기준 2주 뒤 날짜 계산
        const endDate = new Date(dateObj.getTime() + 14 * 24 * 60 * 60 * 1000)

        // 실제 input에 설정
        // document.getElementById('start_date').value = formatDate(dateObj);
        document.getElementById('start_date').value = formatDate(dateObj);
        document.getElementById('end_date').value = formatDate(endDate);

        // 기존 default 컬럼 초기화
        const firstColumn = [];
        defaultColumns.forEach(col => firstColumn.push(col));

        // dateObj ~ endDate 까지 헤더 컬럼 생성 필요
        // 시작일 ~ 종료일까지 반복해서 컬럼 생성
        for (let d = new Date(dateObj); d <= endDate; d.setDate(d.getDate() + 1)) {
            const dateStr = formatDate(d);
            firstColumn.push({
                dataField: dateStr,
                label: dateStr,
                width: 100,
                editable: false
            });
        }

        // 그리드 컬럼가져오기
        // 1. id로 사용할 grid_id(js용)
        // 2. 초기화용 컬럼들 (LIST)
        // <div id="grid" data-grid-id="RESOURCE_GRID"></div>
        $hs.util.$CommonUtil.getGridSetting("grid", firstColumn);





        // demension grid
        $hs.dx.grid.init({
            id: "dimension_grid",
            width: "100%",
            height: "300px",
            sortable: true,
            selectMode: "single",
            dragRow: true,
            rownumber: false,
            filterable: false,
            editable: true,
            handler: true,
        }).columns(col => {
            col.add({ dataField: "dataField", label: "dataField", width: 200, editable: false, visible:false })
            col.add({ dataField: "editable", label: "editable", width: 200, editable: false, visible:false })
            col.add({ dataField: "name", label: "NAME", width: 200, editable: false })
            col.add({ dataField: "visible", label: "VISIBLE", width: 80, editable: true, type: "boolean" })
            col.add({ dataField: "width", label: "WIDTH", width: 80, editable: true })
            col.add({ dataField: "fix", label: "FIX", width: 80, editable: true, type: "boolean" })
        });

        // 사업부
        $hs.html.select.init({
            id: "group_id",
            dataurl: "/api/data/DIVISION_LIST",
            valueMember: "CODE",
            displayMember: "NAME",
            val: ""
        });

        // 사업부
        $hs.html.select.init({
            id: "plan_id",
            dataurl: "/api/data/PLAN_ID",
            valueMember: "PLAN_ID",
            displayMember: "PLAN_ID",
            val: first_plan_id
        });


        // 팝업
        $hs.html.$popup.init('modalDialog');
    });

    // yyyy-mm-dd 포맷으로 변환하는 함수
    function formatDate(date) {
        const yyyy = date.getFullYear();
        const mm = String(date.getMonth() + 1).padStart(2, '0'); // month: 0-based
        const dd = String(date.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }

</script>

<!-- s:Content Header (Page header) -->
<div class="content-header">
    <div class="header-location">
        <div class="header-title">
            <span class="sub-title">제품별</span>
            <div class="toggle-container-favorites">
                <input type="checkbox" id="favorites-toggle" hidden>
                <label for="favorites-toggle" class="favorites-toggle">
                    <i class="bx bx-star"></i>
                </label>
            </div>
        </div>
        <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="#link"><i class="xi-ico xi-home"></i></a></li>
            <li class="breadcrumb-item active">납기분석</li>
            <li class="breadcrumb-item active">제품별</li>
        </ol>
    </div>
    <div class="header-setting">
        <div class="header-btn">
            <div class="filter-toggle-container">
                <span class="toggle-title">Search Area</span>
                <input type="checkbox" id="favorites-toggle-switch" hidden checked>
                <label for="favorites-toggle-switch" class="switch"></label>
            </div>
        </div>
    </div>
</div>
<!-- /e:Content Header -->
<hr>
<!-- s:content -->
<section class="content-body" flex>
    <div class="content row" flex>
        <div class="col-lg-12" flex>
            <div class="content-box content-filter">
                <div class="box-body">
                    <div class="list-filter">
                        <div id="pnlSearch" class="filter-content form-inline">

                            <div class="form-group">
                                <div class="control-label"><label>PLAN ID</label></div>
                                <div class="control-form">
                                    <select class="form-control" id="plan_id" hs-df="PLAN_ID" hs-handler="true"></select>
                                </div>
                            </div>

                            <div class="form-group">
                                <div class="control-label"><label>GROUP</label></div>
                                <div class="control-form">
                                    <select class="form-control" id="group_id" hs-df="group_id"></select>
                                </div>
                            </div>

                            <div class="form-group">
                                <div class="control-label"><label>Customer</label></div>
                                <div class="control-form">
                                    <input type="text" id="customer" hs-df="customer" class="form-control" placeholder="Search">
                                </div>
                            </div>

                            <div class="form-group">
                                <div class="control-label"><label>Item Code</label></div>
                                <div class="control-form">
                                    <input type="text" id="item_code" hs-df="item_code" class="form-control" placeholder="Search">
                                </div>
                            </div>

                            <div class="form-group">
                                <div class="control-label"><label>DATE</label></div>
                                <div class="control-form">
                                    <div class="form-date-period">
                                        <input type="text" id="start_date" hs-df="start_date" class="form-datepicker form-control" data-toggle="datepicker" placeholder="Start Date">
                                        <span class="date-term">~</span>
                                        <input type="text" id="end_date" hs-df="end_date" class="form-datepicker form-control" data-toggle="datepicker" placeholder="End Date">
                                    </div>
                                </div>
                            </div>

                            <button type="button" class="btn btn-reset-icon"><span class="blind">filter reset</span></button>
                            <button id="btnSearch" type="button" class="btn btn-search-icon">Search<span class="blind">filter search</span></button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="content-box" flex>
                <!-- 헤더부분 정의-->
                <div class="box-header">
                    <div class="header-title">제품별 정보<span class="title-list-count"><small></small></span></div>
                    <div class="header-btn">
                        @* <button id="btn_grid_save" type="button" class="btn btn-save">save</button> *@
                        <button id="btn_excel_download" type="button" class="btn btn-download">excel</button>
                        <button id="btn_grid_setting" type="button" class="btn btn-setting-icon"><span class="blind">setting</span></button>
                    </div>
                </div>
                <!-- 바디부분 정의-->
                <div class="box-body" flex>
                    <div class="grid-container" flex>
                        <div id="grid" data-grid-id="ITEM_BY"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
<!-- /e:content -->
<!-- s:modal -->
<div id="modalDialog" style="display:none; position:absolute; height:400px;width:600px;">
    <div class="modal-content animate-top">
        <div id="modal-header" class="modal-header">
            <h5 class="modal-title">PERSONALIZATION</h5>
            <button type="button" class="btn-popup-close">
                <span class="xi-close-min" aria-hidden="true"></span>
            </button>
        </div>
        <div class="modal-body" id="panel_input">
            <div class="row">
                <div class="col-sm-12">
                    <div class="form-group">
                        <div class="control-label"><label>Dimension</label></div>
                    </div>
                </div>
            </div>
            <div class="grid-container" flex>
                <div id="dimension_grid"></div>
            </div>
        </div>
        <div class="modal-footer">
            <button id="btnSave_dimension" type="button" class="btn btn-save">저장</button>
            <button type="button" class="btn btn-close btn-popup-close">닫기</button>
        </div>
    </div>
</div>
<!-- /e:modal -->